<!-- Name: Danie McClanahan -->
<!-- Program Purpose: This is my PVCC ch3 programming file. It will include terminology and definitions from Chapter 5 covering Programming Algorithms & Software Testing-->

    <!DOCTYPE html>
    <html lang = "en">
<head>
        <title> Danie-McClanahan</title>
        <style>
            body {background-color: #BEBAB2; font-family:Arial, Helvetica, sans-serif;}
            table.main {width:90%; border: 8px solid #626980; border-collapse: collapse; color:#626980; margin: auto; background-color: rgb(17, 19, 32, 85%);}
            table.terms {border-top: 1px solid #7E91AF; color:#7E91AF; margin: auto; background-color: rgb(17, 19, 32, 60%); border-collapse: collapse;}
            table.terms td {padding: 5px; }
            h1.first-header {font-size: 20px;}
            h1.second-header {text-align:center; text-decoration:underline; text-decoration-color:#7E91AF; text-decoration-thickness:2px;}
            td.NAVBAR {font-size:large; text-align:center; font-weight:bold; text-decoration:underline; text-decoration-color:#C44940;}
            td.term {margin-bottom:30px; line-height:1.3;}
            li.term {margin-bottom:10px}

            a {text-decoration:none;}
            a:link {color:#C44940;}
            a:visited {color:#644947;}
            a:hover {color:#e7776f;}
            a:active {color:#e7776f;}
        </style>
</head>

<body>
<table class="main">
    <tr>
        <td colspan="4" style="padding:15px;">
            <h1 class="first-header">Danie McClanahan</h1>
        </td>
    </tr>
    <tr>
        <td class="NAVBAR"><a href="index.html"> Home</a></td>
        <td class="NAVBAR"><a href="https://www.pvcc.edu">PVCC</a></td>
        <td class="NAVBAR"><a href="https://www.w3schools.com/html/">W3 Schools</a></td>
        <td class="NAVBAR" style="width: 20%"><a href="contactus.html">Contact Us</a></td>  
    </tr>
    <tr>
        <td colspan="4">
            <table class="terms">
                <tr>
                    <td>
                        <h1 class="second-header">Chapter 5: Programming Algorithms & Software Testing Terminology</h1>
                    </td>
                    <tr>
                        <td class="term">
                            <ul>
                                <li class="term"><u>Phases of coputer program development:</u></li>
                                <ul>
                                    <li>Phase 1: Understanding the Problem</li>
                                    <li>Phase 2: Design an algorithm to solve the problem</li>
                                    <li>Phase 3: Write the program code in appropriate language</li>
                                    <li>Phase 4: Enter the program and save</li>
                                    <li>Phase 5: Execute the program</li>
                                    <li>Phase 6: Test the program, find errors and debug, then reset</li>
                                    <li>Phase 7: Document and evaluate the program</li>
                                </ul>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td class="term">
                            <ul>
                                <li class="term"><u>Programming structures:</u></li>
                                <ul>
                                    <li>Sequential structures: Top-down execution</li>
                                    <li>Decision structures: if/then/else </li>
                                    <li>Iterative (Looping):</li>
                                        <ul>
                                            <li>while looping: continue as long something is true for loop: loop a given number of time</li>
                                        </ul>
                                        <li>Recursive structures:</li>
                                        <ul>
                                            <li>Repeat a set of instructions as a subtask of itself</li>
                                            <li>Repetition continues until:</li>
                                            <ul>
                                                <li>degenerative case, which is termination condition, is met </li>
                                                <li>(degenerative case is also called a "base case")</li>
                                            </ul>
                                        </ul>    
                                </ul>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td class="term">
                            <ul>
                                <li class="term"><u>Two classic programming/database problems</u></li>
                                <ul>
                                    <li>Sorting: Descending order/Ascending order</li>
                                    <ul>
                                        <li>Sorting numbers</li>
                                        <li>Sorting strings (in accordance with ACII values)</li>
                                    </ul>
                                    <li>Searching: fine specific data that meet a certain criteria</li>
                                    <ul>
                                        <li>In database:</li>
                                        <ul>
                                            <li>Filter: temporary search</li>
                                            <li>Queries: search criteria are saved so they dont have to be recreated</li>
                                        </ul>
                                        <li>Two popular search techniques:</li>
                                        <ul>
                                            <li>Sequantial search: seach from top to bottom or bottom to op, one item at a time</li>
                                            <li>Binary search:</li>
                                            <ul>
                                                <li>only works if data is SORTED first</li>
                                                <li>start in the middle, then go to half of that, etc.</li>
                                            </ul>
                                        </ul>
                                    </ul>
                                <li class="term"><u>Two classic program goals:</u></li>
                                <ul>
                                    <li>Efficiency: program takes minimal time and/or resources</li>
                                    <li>Correctness: Program runs in expected ways and works for all expected conditions</li>
                                </ul>
                                <li class="term"><u>There are many different types of software tests, each with specific objectives and strategies:</u></li>
                                <ul>
                                    <li>Acceptance testing: Verifying whether the whole system works as intended.</li>
                                    <li>Code review: Are an effective means to confirm that new and modified software is following an organization's coding standards and adheres to its best practices.</li>
                                    <li>Integration testing: Ensuring that software components or functions operate together.</li>
                                    <li>Unit testing: Validating that each software unit performs as expected. A unit is the smallest testable component of an application.</li>
                                    <li>Functional testing: Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.</li>
                                    <li>Performance testing: Testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.</li>
                                    <li>Regression testing: Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.</li>
                                    <li>Security testing: validate that your software is not open to hacker or other malicious types of vulnerabilities that could be exploited to deny access to your services or cause them to perform incorrectly.</li>
                                    <li>Stress testing: Testing how much strain the system can take before it fails. Considered to be a type of non-functional testing.</li>
                                    <li>Usability testing: Validating how well a customer can use a system or web application to complete a task.</li>
                                </ul>
                            </ul>
                        </ul>
                                <ul>
                                    <li class="term">In each case, validating base requirements is a critical assessment. Just as important, exploratory testing helps a tester or testing team uncover hard-to-predict scenarios and situations that can lead to software errors.</liclass>
                                    <li class="term">Even a simple application can be subject to a large number and variety of tests. A test management plan helps to prioritize which types of testing provide the most value - given available time and resources. Testing effectiveness is optimized by running the fewest number of tests to find the largest number of defects.</li>
                                    <li class="term">Software testing follows a common process. Tasks or steps include defining the test environment, developing test cases, writing scripts, analyzing test results and submitting defect reports.</li>
                                    <li class="term">Testing can be time-consuming. Manual testing or ad-hoc testing may be enough for small builds. However, for larger systems, tools are frequently used to automate tasks. Automated testing helps teams implement different scenarios, test differentiators (such as moving components into a cloud environment), and quickly get feedback on what works and what doesn't.</li>
                                    <li class="term">A good testing approach encompasses the application programming interface (API), user interface and system levels. As well, the more tests that are automated, and run early, the better. Some teams build in-house test automation tools. However, vendor solutions offer features that can streamline key test management tasks such as:</li>
                                    <ul>
                                        <li>Continuous testing: Project teams test each build as it becomes available. This type of software testing relies on test automation that is integrated with the deployment process. It enables software to be validated in realistic test environments earlier in the process - improving design and reducing risks.</li>
                                        <li>Configuration management: Organizations centrally maintain test assets and track what software builds to test. Teams gain access to assets such as code, requirements, design documents, models, test scripts and test results. Good systems include user authentication and audit trails to help teams meet compliance requirements with minimal administrative effort.</li>
                                        <li>Service virtualization: Testing environments may not be available, especially early in code development. Service virtualization simulates the services and systems that are missing or not yet completed, enabling teams to reduce dependencies and test sooner. They can reuse, deploy and change a configuration to test different scenarios without having to modify the original environment.</li>
                                        <li>Defect or bug tracking: Monitoring defects is important to both testing and development teams for measuring and improving quality. Automated tools allow teams to track defects, measure their scope and impact, and uncover related issues.</li>
                                        <li>Metrics and reporting: Reporting and analytics enable team members to share status, goals and test results. Advanced tools integrate project metrics and present results in a dashboard. Teams quickly see the overall health of a project and can monitor relationships between test, development and other project elements.</li>
                                    </ul>
                                </ul>
                            </ul>
                        </td>
                    </tr>
                </tr>
            </table>
        </td>
    </tr>    
</table>
</body>
</html>